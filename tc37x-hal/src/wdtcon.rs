// Copyright (c) 2023 HighTec EDV-Systeme GmbH. All rights reserved.
//
// Use of this file is subject to the Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// lock/unlock the EDNINIT bit in the cpu WDTCON and safety WDTCON
// to access ENDINIT protected SFRs such as BIV, BTY, CLC.

use core::arch::asm;

use tc37xpd::{RegisterValue, SCU};

/// Clears endinit bit for  protection against unintentional modifications.
/// See section 11.4 of AURIXTM TC3xx Target specification
pub fn clear_safety_endinit() {
    let wdts = SCU.wdts();

    let mut passwd = unsafe { wdts.wdtscon0().read().get_raw() };
    passwd &= 0xffffff00;

    unsafe { wdts.wdtscon0().modify(|r| r.set_raw(passwd | 0xf1)) };
    unsafe {
        asm! {"dsync"}
    };
    unsafe { wdts.wdtscon0().modify(|r| r.set_raw(passwd | 0xf2)) };
    // read back new value >
    let _ = unsafe { wdts.wdtscon0().read().get_raw() };
}

/// Sets endinit bit for  protection against unintentional modifications.
pub fn set_safety_endinit() {
    let wdts = SCU.wdts();

    let mut passwd = unsafe { wdts.wdtscon0().read().get_raw() };
    passwd &= 0xffffff00;

    unsafe { wdts.wdtscon0().modify(|r| r.set_raw(passwd | 0xf1)) };
    unsafe {
        asm! {"dsync"}
    };
    passwd |= 3;
    unsafe { wdts.wdtscon0().modify(|r| r.set_raw(passwd | 0xf2)) };
    // read back new value >
    let _ = unsafe { wdts.wdtscon0().read().get_raw() };
}

/// Clears endinit bit for  protection against unintentional modifications for CPU0 core.
/// See section 11.4 of AURIXTM TC3xx Target specification
pub fn clear_cpu_endinit() {
    let mut passwd = unsafe { SCU.wdtcpu0con0().read().get_raw() };
    passwd &= 0xffffff00;

    unsafe { SCU.wdtcpu0con0().modify(|r| r.set_raw(passwd | 0xf1)) };
    unsafe {
        asm! {"dsync"}
    };
    unsafe { SCU.wdtcpu0con0().modify(|r| r.set_raw(passwd | 0xf2)) };
    // read back new value >
    let _ = unsafe { SCU.wdtcpu0con0().read().get_raw() };
}

/// Sets endinit bit for  protection against unintentional modifications for current core.
pub fn set_cpu_endinit() {
    let mut passwd = unsafe { SCU.wdtcpu0con0().read().get_raw() };
    passwd &= 0xffffff00;

    unsafe { SCU.wdtcpu0con0().modify(|r| r.set_raw(passwd | 0xf1)) };
    unsafe {
        asm! {"dsync"}
    };
    passwd |= 3;
    unsafe { SCU.wdtcpu0con0().modify(|r| r.set_raw(passwd | 0xf2)) };
    // read back new value >
    let _ = unsafe { SCU.wdtcpu0con0().read().get_raw() };
}

/// Disable safety watchdog. The Safety Watchdog Timer provides an overall system level watchdog which is independent from the CPU Watchdog Timers
/// See section 11.4 of AURIXTM TC3xx Target specification
#[no_mangle]
pub fn disable_safety_watchdog() {
    let wdts = SCU.wdts();

    clear_safety_endinit();
    unsafe {
        wdts.wdtscon1().modify(|r| r.dr().set(1.into()));
    }
    set_safety_endinit();
}

/// Disable safety watchdog for CPU0 core.
/// See section 11.4 of AURIXTM TC3xx Target specification
#[no_mangle]
pub fn disable_cpu_watchdog() {
    clear_cpu_endinit();
    unsafe {
        SCU.wdtcpu0con1().modify(|r| r.dr().set(true));
    }
    set_cpu_endinit();
}

///  This function can call any other function, a lambda function or any callable without CPU endinit protection.
///
/// ### Example
/// ``` rust
///  tc3xx_service::call_without_cpu_endinit(|| unsafe {
///     const BIV: u16 = 0xFE20;
///     let interrupt_table = core::ptr::addr_of!(__INTERRUPT_TABLE) as u32;
///     mtcr::<BIV>(interrupt_table);
/// });
/// ```
pub fn call_without_cpu_endinit(f: impl Fn()) {
    crate::wdtcon::clear_cpu_endinit();
    f();
    crate::wdtcon::set_cpu_endinit();
}

/// This function can call any other function, a lambda function or any callable
/// without safety endinit protection.
///
/// ### Example
/// ``` rust
///  tc3xx_service::call_without_safety_endinit(|| unsafe {
///     const BIV: u16 = 0xFE20;
///     let interrupt_table = core::ptr::addr_of!(__INTERRUPT_TABLE) as u32;
///     mtcr::<BIV>(interrupt_table);
/// });
/// ```
pub fn call_without_safety_endinit(f: impl Fn()) {
    crate::wdtcon::clear_safety_endinit();
    f();
    crate::wdtcon::set_safety_endinit();
}
